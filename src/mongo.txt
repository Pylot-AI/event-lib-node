import { Db } from "mongodb";
import { ESEvent, ESStack, LocalStore } from "./types";

export interface MongoStackOptions {
    db: Db;
    collection: string;
    namespace: string;
}


function createDDBStack(options: MongoStackOptions): ESStack {
    let lastVerifiedId = -1;

    async function commitEvent(ev: ESEvent) {
        await options.db.collection(options.collection).index
        if (ev.id < 0) return;
        if (ev.id !== lastVerifiedId + 1) {
            const itemBefore = await getEvent(ev.id - 1);
            if (!itemBefore) throw new Error(`Event too far ahead. An event with id: ${ev.id - 1} doesn't exist yet so an event with id: ${ev.id} cannot be created.`);
            lastVerifiedId = itemBefore.id;
        }

        const event = {
            ...ev,
            namespace: options.namespace,
        };

        try {
            await options.db.collection(options.collection).updateOne({}, {}, {upsert: });
        } catch (ex) {
            if (~ex?.message?.indexOf("[ConditionalCheckFailed")) {
                console.log(`An event with id: ${event.id} already exists`);
            }

            if (~ex?.message?.indexOf("ConditionalCheckFailed]")) {
                console.log(`Event too far ahead. An event with id: ${event.id - 1} doesn't exist yet so an event with id: ${event.id} cannot be created.`);
            }

            throw ex;
        }
    }

    async function commitAnonymousEvent(ev: ESEvent) {
        const res = await options.ddb.query({
            TableName: options.tablename,
            KeyConditionExpression: "#ns=:ns",
            ScanIndexForward: false,
            ExpressionAttributeNames: {
                "#ns": "namespace",
            },
            ExpressionAttributeValues: {
                ":ns": options.namespace,
            },
            Limit: 1,
        }).promise();

        const lastEvent = res?.Items?.[0];
        const nextEventId = (lastEvent?.id ?? -1) + 1;

        return await commitEvent({
            ...ev,
            id: nextEventId,
        });
    }

    async function getEvent(id: number) {
        const event = await options.ddb.get({
            TableName: options.tablename,
            Key: {
                namespace: options.namespace,
                id: id,
            },
        }).promise();

        return event.Item as ESEvent;
    }

    async function slice(start?: number, end?: number) {
        const res = await options.ddb.query({
            TableName: options.tablename,
            KeyConditionExpression: "#ns=:ns and #id >= :start",
            ExpressionAttributeNames: {
                "#ns": "namespace",
                "#id": "id",
            },
            ExpressionAttributeValues: {
                ":ns": options.namespace,
                ":start": start,
            },
        }).promise();

        const items: ESEvent[] = res.Items as ESEvent[];
        return items;
    }

    return {
        commitAnonymousEvent,
        commitEvent,
        getEvent,
        slice,
    };
}

export function ddbStore(): LocalStore {
    const ddb = new DynamoDB.DocumentClient({
        region: "us-west-2",
    });
    const stacks = new Map<string, ESStack>();

    async function getStack(name: string): Promise<ESStack> {
        return stacks.get(name);
    }

    async function createStack(name: string): Promise<ESStack> {
        const stack = createDDBStack({
            ddb,
            namespace: name,
            tablename: `sctrl2-events`,
        });
        stacks.set(name, stack);
        return stack;
    }

    async function getOrCreateStack(name: string): Promise<ESStack> {
        const existingStack = await getStack(name);
        return existingStack
            ? existingStack
            : await createStack(name);
    }

    return {
        getStack,
        createStack,
        getOrCreateStack,
    };
}
